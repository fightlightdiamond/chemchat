import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { PrismaService } from '../../shared/infrastructure/prisma/prisma.service';
import { RedisService } from '../../shared/redis/redis.service';

const execAsync = promisify(exec);

export enum ScanType {
  DEPENDENCIES = 'dependencies',
  CODE_QUALITY = 'code_quality',
  SECURITY = 'security',
  SECRETS = 'secrets',
  CONFIGURATION = 'configuration',
}

export interface ScanResult {
  scanId: string;
  type: ScanType;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  issues: VulnerabilityIssue[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  startedAt: Date;
  completedAt?: Date;
  error?: string;
}

export interface VulnerabilityIssue {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  category: string;
  file?: string;
  line?: number;
  codeSnippet?: string;
  recommendation?: string;
  cve?: string;
  cvssScore?: number;
  references?: string[];
  firstSeen: Date;
  lastSeen: Date;
  status:
    | 'new'
    | 'confirmed'
    | 'false_positive'
    | 'mitigated'
    | 'risk_accepted';
}

@Injectable()
export class VulnerabilityScanningService {
  private readonly logger = new Logger(VulnerabilityScanningService.name);
  private readonly scanResults = new Map<string, ScanResult>();
  private readonly SCAN_RESULTS_KEY = 'vulnerability:scan:results';
  private readonly SCAN_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
  private readonly TEMP_DIR = path.join(os.tmpdir(), 'chemchat-scans');

  constructor(
    private readonly config: ConfigService,
    private readonly prisma: PrismaService,
    private readonly redis: RedisService,
  ) {
    // Ensure temp directory exists
    if (!fs.existsSync(this.TEMP_DIR)) {
      fs.mkdirSync(this.TEMP_DIR, { recursive: true });
    }

    // Schedule regular scans
    this.scheduleScans();
  }

  async startScan(type: ScanType): Promise<string> {
    const scanId = `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const scanResult: ScanResult = {
      scanId,
      type,
      status: 'in_progress',
      issues: [],
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      startedAt: new Date(),
    };

    // Store in memory and Redis
    this.scanResults.set(scanId, scanResult);
    await this.redis.hset(
      this.SCAN_RESULTS_KEY,
      scanId,
      JSON.stringify(scanResult),
    );

    // Start scan in background
    this.performScan(scanId, type).catch((error) => {
      this.logger.error(`Scan ${scanId} failed: ${error.message}`, error.stack);
    });

    return scanId;
  }

  async getScanResult(scanId: string): Promise<ScanResult | null> {
    // Check in-memory cache first
    if (this.scanResults.has(scanId)) {
      return this.scanResults.get(scanId)!;
    }

    // Check Redis
    const result = await this.redis.hget(this.SCAN_RESULTS_KEY, scanId);
    if (result) {
      return JSON.parse(result) as ScanResult;
    }

    // Database fallback not implemented yet
    return null;
  }

  async getLatestScanResults(limit = 10): Promise<ScanResult[]> {
    // Get from Redis first
    const redisResults = await this.redis.hgetall(this.SCAN_RESULTS_KEY);
    const results = Object.values(redisResults)
      .map((r) => JSON.parse(r) as ScanResult)
      .sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime())
      .slice(0, limit);

    // Database fallback not implemented yet
    // if (results.length < limit) {
    //   // Would fetch from database here
    // }

    return results;
  }

  private async performScan(scanId: string, type: ScanType): Promise<void> {
    try {
      let issues: VulnerabilityIssue[] = [];

      switch (type) {
        case ScanType.DEPENDENCIES:
          issues = await this.scanDependencies();
          break;
        case ScanType.CODE_QUALITY:
          issues = await this.scanCodeQuality();
          break;
        case ScanType.SECURITY:
          issues = await this.scanSecurity();
          break;
        case ScanType.SECRETS:
          issues = await this.scanForSecrets();
          break;
        case ScanType.CONFIGURATION:
          issues = await this.scanConfiguration();
          break;
        default:
          throw new Error(`Unsupported scan type: ${type}`);
      }

      // Update scan result
      const summary = this.calculateSummary(issues);
      const completedAt = new Date();

      const scanResult: ScanResult = {
        scanId,
        type,
        status: 'completed',
        issues,
        summary,
        startedAt: new Date(),
        completedAt,
      };

      // Update in memory and Redis
      this.scanResults.set(scanId, scanResult);
      await this.redis.hset(
        this.SCAN_RESULTS_KEY,
        scanId,
        JSON.stringify(scanResult),
      );

      // Save to database
      await this.saveScanResult(scanResult);

      // Log completion
      this.logger.log(
        `Scan ${scanId} completed with ${issues.length} issues found`,
      );

      // Trigger alerts if critical/high severity issues found
      if (summary.critical > 0 || summary.high > 0) {
        await this.triggerSecurityAlerts(scanResult);
      }
    } catch (error) {
      this.logger.error(`Scan ${scanId} failed: ${error.message}`, error.stack);

      // Update scan result with error
      const scanResult = this.scanResults.get(scanId) || {
        scanId,
        type,
        status: 'failed',
        issues: [],
        summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0, info: 0 },
        startedAt: new Date(),
      };

      scanResult.status = 'failed';
      scanResult.error = error.message;

      // Update in memory and Redis
      this.scanResults.set(scanId, scanResult);
      await this.redis.hset(
        this.SCAN_RESULTS_KEY,
        scanId,
        JSON.stringify(scanResult),
      );

      // Save to database
      await this.saveScanResult(scanResult);
    }
  }

  private async scanDependencies(): Promise<VulnerabilityIssue[]> {
    // Implement dependency scanning using npm audit or similar
    try {
      const { stdout } = await execAsync('npm audit --json');
      const auditResults = JSON.parse(stdout);
      return this.parseNpmAuditResults(auditResults);
    } catch (error) {
      this.logger.error('Dependency scan failed', error);
      return [];
    }
  }

  private async scanCodeQuality(): Promise<VulnerabilityIssue[]> {
    // Implement code quality scanning using ESLint or similar
    // This is a placeholder implementation
    return [];
  }

  private async scanSecurity(): Promise<VulnerabilityIssue[]> {
    // Implement security scanning using NodeJsScan or similar
    // This is a placeholder implementation
    return [];
  }

  private async scanForSecrets(): Promise<VulnerabilityIssue[]> {
    // Implement secrets scanning using detect-secrets or similar
    // This is a placeholder implementation
    return [];
  }

  private async scanConfiguration(): Promise<VulnerabilityIssue[]> {
    // Implement configuration scanning
    // This is a placeholder implementation
    return [];
  }

  private mapSeverity(
    severity: string,
  ): 'critical' | 'high' | 'medium' | 'low' | 'info' {
    switch (severity?.toLowerCase()) {
      case 'critical':
        return 'critical';
      case 'high':
        return 'high';
      case 'moderate':
        return 'medium';
      case 'low':
        return 'low';
      default:
        return 'info';
    }
  }

  private parseNpmAuditResults(auditResults: any): VulnerabilityIssue[] {
    // Parse npm audit results into our vulnerability format
    // This is a simplified implementation
    const issues: VulnerabilityIssue[] = [];
    const now = new Date();

    if (auditResults.vulnerabilities) {
      for (const [pkg, vuln] of Object.entries(
        auditResults.vulnerabilities as Record<string, any>,
      )) {
        issues.push({
          id: `npm-${pkg}-${vuln.via[0]}`,
          title: `${vuln.severity} severity vulnerability in ${pkg}`,
          description: vuln.description || 'No description available',
          severity: this.mapSeverity(vuln.severity),
          category: 'dependencies',
          recommendation: `Upgrade to version ${vuln.fixAvailable ? vuln.fixAvailable : 'latest'}`,
          cve: vuln.cves && vuln.cves.length > 0 ? vuln.cves[0] : undefined,
          cvssScore: vuln.cvss?.score,
          references: vuln.via
            ?.filter((v: any) => typeof v === 'string')
            .slice(0, 3),
          firstSeen: now,
          lastSeen: now,
          status: 'new',
        });
      }
    }

    return issues;
  }

  private calculateSummary(
    issues: VulnerabilityIssue[],
  ): ScanResult['summary'] {
    return issues.reduce(
      (acc, issue) => {
        acc.total++;
        acc[issue.severity]++;
        return acc;
      },
      { total: 0, critical: 0, high: 0, medium: 0, low: 0, info: 0 },
    );
  }

  private async saveScanResult(scanResult: ScanResult): Promise<void> {
    // Database persistence not implemented yet
    // await this.prisma.vulnerabilityScan.upsert({
    //   where: { id: scanResult.scanId },
    //   update: {
    //     type: scanResult.type,
    //     status: scanResult.status,
    //     issues: scanResult.issues,
    //     summary: scanResult.summary,
    //     startedAt: scanResult.startedAt,
    //     completedAt: scanResult.completedAt,
    //     error: scanResult.error,
    //   },
    //   create: {
    //     id: scanResult.scanId,
    //     type: scanResult.type,
    //     status: scanResult.status,
    //     issues: scanResult.issues,
    //     summary: scanResult.summary,
    //     startedAt: scanResult.startedAt,
    //     completedAt: scanResult.completedAt,
    //     error: scanResult.error,
    //   },
    // });

    // Store in Redis for now
    await this.redis.hset(
      this.SCAN_RESULTS_KEY,
      scanResult.scanId,
      JSON.stringify(scanResult),
    );
  }

  private async triggerSecurityAlerts(scanResult: ScanResult): Promise<void> {
    // Implement alerting logic (email, Slack, etc.)
    const criticalCount = scanResult.summary.critical;
    const highCount = scanResult.summary.high;

    this.logger.warn(
      `Security scan ${scanResult.scanId} found ${criticalCount} critical and ${highCount} high severity issues`,
    );

    // TODO: Send alerts to configured channels
  }

  private scheduleScans(): void {
    // Schedule regular scans based on configuration
    const scanInterval = this.config.get<number>(
      'VULNERABILITY_SCAN_INTERVAL_MS',
      this.SCAN_INTERVAL,
    );

    setInterval(async () => {
      try {
        await this.startScan(ScanType.DEPENDENCIES);
        await this.startScan(ScanType.SECURITY);
      } catch (error) {
        this.logger.error('Scheduled scan failed', error);
      }
    }, scanInterval);
  }

  private mapDbToScanResult(dbResult: any): ScanResult {
    return {
      scanId: dbResult.id,
      type: dbResult.type as ScanType,
      status: dbResult.status as
        | 'pending'
        | 'in_progress'
        | 'completed'
        | 'failed',
      issues: dbResult.issues as VulnerabilityIssue[],
      summary: dbResult.summary as ScanResult['summary'],
      startedAt: dbResult.startedAt,
      completedAt: dbResult.completedAt || undefined,
      error: dbResult.error || undefined,
    };
  }
}
