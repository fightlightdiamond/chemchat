// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Users table with authentication and MFA support
model User {
  id           String   @id @default(uuid())
  username     String   @unique @db.VarChar(50)
  displayName  String   @map("display_name") @db.VarChar(100)
  email        String   @unique @db.VarChar(255)
  passwordHash String   @map("password_hash") @db.VarChar(255)
  mfaEnabled   Boolean  @default(false) @map("mfa_enabled")
  mfaSecret    String?  @map("mfa_secret") @db.VarChar(255)
  lastLoginAt  DateTime? @map("last_login_at") @db.Timestamptz(6)
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  ownedConversations      Conversation[]           @relation("ConversationOwner")
  conversationMembers     ConversationMember[]
  sentMessages            Message[]                @relation("MessageSender")
  messageReactions        MessageReaction[]
  auditLogs               AuditLog[]               @relation("AuditActor")
  notificationPreferences NotificationPreference[] @relation("UserNotificationPreferences")
  deviceTokens            DeviceToken[]            @relation("UserDeviceTokens")
  notifications           NotificationDelivery[]   @relation("UserNotifications")
  attachments             Attachment[]             @relation("AttachmentUploader")

  @@map("users")
}

// Conversations table supporting both DM and group chats
model Conversation {
  id        String            @id @default(uuid())
  type      ConversationType
  name      String?           @db.VarChar(100)
  ownerId   String?           @map("owner_id")
  createdAt DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  owner               User?                 @relation("ConversationOwner", fields: [ownerId], references: [id])
  members             ConversationMember[]
  messages            Message[]
  conversationState   ConversationState?

  @@map("conversations")
}

// Conversation members with roles and read tracking
model ConversationMember {
  conversationId      String   @map("conversation_id")
  userId              String   @map("user_id")
  role                MemberRole @default(MEMBER)
  lastReadMessageId   String?  @map("last_read_message_id")
  lastReadSequence    BigInt   @default(0) @map("last_read_sequence")
  joinedAt            DateTime @default(now()) @map("joined_at") @db.Timestamptz(6)

  // Relationships
  conversation        Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user                User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  lastReadMessage     Message?     @relation("LastReadMessage", fields: [lastReadMessageId], references: [id])

  @@id([conversationId, userId])
  @@index([userId])
  @@map("conversation_members")
}

// Messages with sequence ordering and content support
model Message {
  id                String      @id @default(uuid())
  conversationId    String      @map("conversation_id")
  senderId          String?     @map("sender_id")
  clientMessageId   String?     @map("client_message_id") @db.VarChar(100)
  sequenceNumber    BigInt      @map("sequence_number")
  messageType       MessageType @default(TEXT) @map("message_type")
  content           Json
  editedAt          DateTime?   @map("edited_at") @db.Timestamptz(6)
  deletedAt         DateTime?   @map("deleted_at") @db.Timestamptz(6)
  createdAt         DateTime    @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  conversation      Conversation        @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender            User?               @relation("MessageSender", fields: [senderId], references: [id])
  reactions         MessageReaction[]
  attachments       Attachment[]
  lastReadBy        ConversationMember[] @relation("LastReadMessage")

  @@unique([conversationId, sequenceNumber])
  @@unique([conversationId, clientMessageId, senderId])
  @@index([conversationId, sequenceNumber(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("messages")
}

// Message reactions
model MessageReaction {
  messageId String   @map("message_id")
  userId    String   @map("user_id")
  emoji     String   @db.VarChar(10)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId, emoji])
  @@map("message_reactions")
}

// Conversation state for sequence number fallback
model ConversationState {
  conversationId String   @id @map("conversation_id")
  lastSeq        BigInt   @default(0) @map("last_seq")
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@map("conversation_state")
}

// Media attachments with enhanced metadata
model Attachment {
  id               String            @id @default(uuid())
  messageId        String            @map("message_id")
  filename         String            @db.VarChar(255)
  originalFilename String            @map("original_filename") @db.VarChar(255)
  mimeType         String            @map("mime_type") @db.VarChar(100)
  fileSize         BigInt            @map("file_size")
  fileHash         String            @map("file_hash") @db.VarChar(64)
  storageUrl       String            @map("storage_url")
  thumbnailUrl     String?           @map("thumbnail_url")
  previewUrl       String?           @map("preview_url")
  uploadStatus     MediaUploadStatus @default(PENDING) @map("upload_status")
  processingStatus MediaProcessingStatus @default(PENDING) @map("processing_status")
  metadata         Json?             // EXIF data, dimensions, duration, etc.
  virusScanStatus  VirusScanStatus   @default(PENDING) @map("virus_scan_status")
  virusScanResult  String?           @map("virus_scan_result")
  contentSafety    Json?             @map("content_safety") // Content moderation results
  cdnUrl           String?           @map("cdn_url")
  expiresAt        DateTime?         @map("expires_at") @db.Timestamptz(6)
  tenantId         String?           @map("tenant_id")
  uploadedBy       String            @map("uploaded_by")
  createdAt        DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime          @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  message          Message           @relation(fields: [messageId], references: [id], onDelete: Cascade)
  uploader         User              @relation("AttachmentUploader", fields: [uploadedBy], references: [id])
  mediaProcessing  MediaProcessing[]

  @@index([messageId])
  @@index([uploadedBy])
  @@index([tenantId])
  @@index([fileHash])
  @@index([uploadStatus])
  @@index([virusScanStatus])
  @@map("attachments")
}

// Media processing jobs and results
model MediaProcessing {
  id           String                @id @default(uuid())
  attachmentId String                @map("attachment_id")
  jobType      MediaProcessingType   @map("job_type")
  status       MediaProcessingStatus @default(PENDING)
  priority     ProcessingPriority    @default(NORMAL)
  inputUrl     String                @map("input_url")
  outputUrl    String?               @map("output_url")
  parameters   Json?                 // Processing parameters (size, quality, etc.)
  result       Json?                 // Processing results and metadata
  error        String?               // Error message if failed
  attempts     Int                   @default(0)
  maxAttempts  Int                   @default(3) @map("max_attempts")
  scheduledAt  DateTime?             @map("scheduled_at") @db.Timestamptz(6)
  startedAt    DateTime?             @map("started_at") @db.Timestamptz(6)
  completedAt  DateTime?             @map("completed_at") @db.Timestamptz(6)
  tenantId     String?               @map("tenant_id")
  createdAt    DateTime              @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime              @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  attachment   Attachment            @relation(fields: [attachmentId], references: [id], onDelete: Cascade)

  @@index([attachmentId])
  @@index([status])
  @@index([jobType])
  @@index([priority])
  @@index([scheduledAt])
  @@index([tenantId])
  @@map("media_processing")
}

// Media quota tracking per tenant
model MediaQuota {
  id              String   @id @default(uuid())
  tenantId        String   @unique @map("tenant_id")
  storageUsed     BigInt   @default(0) @map("storage_used") // bytes
  storageLimit    BigInt   @map("storage_limit") // bytes
  uploadCount     Int      @default(0) @map("upload_count")
  uploadLimit     Int      @map("upload_limit")
  bandwidthUsed   BigInt   @default(0) @map("bandwidth_used") // bytes
  bandwidthLimit  BigInt   @map("bandwidth_limit") // bytes
  resetAt         DateTime @map("reset_at") @db.Timestamptz(6) // monthly reset
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@map("media_quotas")
}

// Audit logs for compliance and moderation
model AuditLog {
  id         String   @id @default(uuid())
  tenantId   String?  @map("tenant_id")
  actorId    String?  @map("actor_id")
  action     String   @db.VarChar(50)
  targetType String   @map("target_type") @db.VarChar(50)
  targetId   String   @map("target_id")
  metadata   Json?
  ipAddress  String?  @map("ip_address")
  userAgent  String?  @map("user_agent")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  actor      User?    @relation("AuditActor", fields: [actorId], references: [id])

  @@index([actorId, createdAt(sort: Desc)])
  @@map("audit_logs")
}

// Outbox pattern for reliable event publishing
model OutboxEvent {
  id            String    @id @default(uuid())
  tenantId      String?   @map("tenant_id")
  aggregateType String    @map("aggregate_type") @db.VarChar(50)
  aggregateId   String    @map("aggregate_id")
  eventType     String    @map("event_type") @db.VarChar(100)
  eventData     Json      @map("event_data")
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  publishedAt   DateTime? @map("published_at") @db.Timestamptz(6)
  retryCount    Int       @default(0) @map("retry_count")

  @@index([createdAt])
  @@map("outbox_events")
}

// Notification preferences for users
model NotificationPreference {
  id                    String  @id @default(uuid())
  userId                String  @map("user_id")
  tenantId              String? @map("tenant_id")
  pushEnabled           Boolean @default(true) @map("push_enabled")
  emailEnabled          Boolean @default(true) @map("email_enabled")
  mentionNotifications  Boolean @default(true) @map("mention_notifications")
  dmNotifications       Boolean @default(true) @map("dm_notifications")
  groupNotifications    Boolean @default(true) @map("group_notifications")
  quietHoursEnabled     Boolean @default(false) @map("quiet_hours_enabled")
  quietHoursStart       String? @map("quiet_hours_start") @db.VarChar(5) // HH:MM format
  quietHoursEnd         String? @map("quiet_hours_end") @db.VarChar(5)   // HH:MM format
  timezone              String  @default("UTC") @db.VarChar(50)
  createdAt             DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user User @relation("UserNotificationPreferences", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@map("notification_preferences")
}

// Device tokens for push notifications
model DeviceToken {
  id           String            @id @default(uuid())
  userId       String            @map("user_id")
  tenantId     String?           @map("tenant_id")
  deviceId     String            @map("device_id") @db.VarChar(255)
  token        String            @db.VarChar(500)
  platform     DevicePlatform
  appVersion   String?           @map("app_version") @db.VarChar(50)
  isActive     Boolean           @default(true) @map("is_active")
  lastUsedAt   DateTime          @default(now()) @map("last_used_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user          User                   @relation("UserDeviceTokens", fields: [userId], references: [id], onDelete: Cascade)
  notifications NotificationDelivery[] @relation("DeviceNotifications")

  @@unique([userId, deviceId, tenantId])
  @@index([userId, isActive])
  @@map("device_tokens")
}

// Notification delivery tracking
model NotificationDelivery {
  id                String                    @id @default(uuid())
  tenantId          String?                   @map("tenant_id")
  userId            String                    @map("user_id")
  notificationType  NotificationType          @map("notification_type")
  deliveryChannel   NotificationChannel       @map("delivery_channel")
  status            NotificationStatus
  title             String                    @db.VarChar(255)
  body              String                    @db.Text
  data              Json?
  deviceTokenId     String?                   @map("device_token_id")
  externalId        String?                   @map("external_id") @db.VarChar(255) // Firebase/Email service ID
  errorMessage      String?                   @map("error_message") @db.Text
  retryCount        Int                       @default(0) @map("retry_count")
  scheduledAt       DateTime?                 @map("scheduled_at") @db.Timestamptz(6)
  sentAt            DateTime?                 @map("sent_at") @db.Timestamptz(6)
  deliveredAt       DateTime?                 @map("delivered_at") @db.Timestamptz(6)
  readAt            DateTime?                 @map("read_at") @db.Timestamptz(6)
  createdAt         DateTime                  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt         DateTime                  @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user        User         @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  deviceToken DeviceToken? @relation("DeviceNotifications", fields: [deviceTokenId], references: [id])

  @@index([userId, status, createdAt(sort: Desc)])
  @@index([tenantId, status, createdAt(sort: Desc)])
  @@index([scheduledAt])
  @@map("notification_deliveries")
}

// Notification templates
model NotificationTemplate {
  id          String               @id @default(uuid())
  tenantId    String?              @map("tenant_id")
  name        String               @db.VarChar(100)
  type        NotificationType
  channel     NotificationChannel
  subject     String?              @db.VarChar(255) // For email notifications
  title       String               @db.VarChar(255)
  body        String               @db.Text
  variables   Json?                // Template variables schema
  isActive    Boolean              @default(true) @map("is_active")
  createdAt   DateTime             @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime             @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@unique([tenantId, name, type, channel])
  @@map("notification_templates")
}

// Enums
enum ConversationType {
  DM    @map("dm")
  GROUP @map("group")
}

enum MemberRole {
  OWNER  @map("owner")
  ADMIN  @map("admin")
  MEMBER @map("member")
}

enum MessageType {
  TEXT   @map("text")
  IMAGE  @map("image")
  FILE   @map("file")
  SYSTEM @map("system")
}

enum DevicePlatform {
  IOS     @map("ios")
  ANDROID @map("android")
  WEB     @map("web")
}

enum NotificationType {
  NEW_MESSAGE           @map("new_message")
  MENTION               @map("mention")
  CONVERSATION_INVITE   @map("conversation_invite")
  USER_JOINED           @map("user_joined")
  USER_LEFT             @map("user_left")
  MESSAGE_REACTION      @map("message_reaction")
  SYSTEM_ANNOUNCEMENT   @map("system_announcement")
}

enum NotificationChannel {
  PUSH  @map("push")
  EMAIL @map("email")
  SMS   @map("sms")
}

enum NotificationStatus {
  PENDING    @map("pending")
  SCHEDULED  @map("scheduled")
  SENT       @map("sent")
  DELIVERED  @map("delivered")
  READ       @map("read")
  FAILED     @map("failed")
  CANCELLED  @map("cancelled")
}

enum MediaUploadStatus {
  PENDING    @map("pending")
  UPLOADING  @map("uploading")
  UPLOADED   @map("uploaded")
  FAILED     @map("failed")
  CANCELLED  @map("cancelled")
}

enum MediaProcessingStatus {
  PENDING      @map("pending")
  PROCESSING   @map("processing")
  COMPLETED    @map("completed")
  FAILED       @map("failed")
  SKIPPED      @map("skipped")
}

enum MediaProcessingType {
  THUMBNAIL_GENERATION @map("thumbnail_generation")
  IMAGE_RESIZE         @map("image_resize")
  VIDEO_TRANSCODE      @map("video_transcode")
  AUDIO_TRANSCODE      @map("audio_transcode")
  EXIF_STRIP           @map("exif_strip")
  WATERMARK            @map("watermark")
  VIRUS_SCAN           @map("virus_scan")
  CONTENT_MODERATION   @map("content_moderation")
}

enum ProcessingPriority {
  LOW      @map("low")
  NORMAL   @map("normal")
  HIGH     @map("high")
  URGENT   @map("urgent")
}

enum VirusScanStatus {
  PENDING    @map("pending")
  SCANNING   @map("scanning")
  CLEAN      @map("clean")
  INFECTED   @map("infected")
  FAILED     @map("failed")
  SKIPPED    @map("skipped")
}
