// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Tenants table for multi-tenancy support
model Tenant {
  id               String           @id @default(uuid())
  name             String           @unique @db.VarChar(100)
  subscriptionTier SubscriptionTier @default(FREE) @map("subscription_tier")
  isActive         Boolean          @default(true) @map("is_active")
  createdAt        DateTime         @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime         @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  settings TenantSettings?
  quota    TenantQuota?
  usage    TenantUsage?

  @@map("tenants")
}

// Tenant settings and configuration
model TenantSettings {
  tenantId          String   @id @map("tenant_id")
  allowFileUploads  Boolean  @default(true) @map("allow_file_uploads")
  maxFileSize       Int      @map("max_file_size") // bytes
  allowedFileTypes  String[] @map("allowed_file_types")
  retentionDays     Int      @default(30) @map("retention_days")
  enableNotifications Boolean @default(true) @map("enable_notifications")
  enableSearch      Boolean  @default(true) @map("enable_search")
  customBranding    Boolean  @default(false) @map("custom_branding")
  ssoEnabled        Boolean  @default(false) @map("sso_enabled")
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt         DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("tenant_settings")
}

// Tenant quota limits
model TenantQuota {
  tenantId                String @id @map("tenant_id")
  maxUsers                Int    @map("max_users")
  maxConversations        Int    @map("max_conversations")
  maxMessagesPerDay       Int    @map("max_messages_per_day")
  maxStorageBytes         BigInt @map("max_storage_bytes")
  maxConnectionsPerUser   Int    @map("max_connections_per_user")
  maxApiRequestsPerHour   Int    @map("max_api_requests_per_hour")
  createdAt               DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt               DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("tenant_quotas")
}

// Tenant usage tracking
model TenantUsage {
  tenantId              String   @id @map("tenant_id")
  currentUsers          Int      @default(0) @map("current_users")
  currentConversations  Int      @default(0) @map("current_conversations")
  messagesUsedToday     Int      @default(0) @map("messages_used_today")
  storageUsedBytes      BigInt   @default(0) @map("storage_used_bytes")
  currentConnections    Int      @default(0) @map("current_connections")
  apiRequestsThisHour   Int      @default(0) @map("api_requests_this_hour")
  createdAt             DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("tenant_usage")
}

// Users table with authentication and MFA support
model User {
  id           String   @id @default(uuid())
  username     String   @unique @db.VarChar(50)
  displayName  String   @map("display_name") @db.VarChar(100)
  email        String   @unique @db.VarChar(255)
  passwordHash String   @map("password_hash") @db.VarChar(255)
  mfaEnabled   Boolean  @default(false) @map("mfa_enabled")
  mfaSecret    String?  @map("mfa_secret") @db.VarChar(255)
  lastLoginAt  DateTime? @map("last_login_at") @db.Timestamptz(6)
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  ownedConversations      Conversation[]           @relation("ConversationOwner")
  conversationMembers     ConversationMember[]
  sentMessages            Message[]                @relation("MessageSender")
  messageReactions        MessageReaction[]
  auditLogs               AuditLog[]               @relation("AuditActor")
  notificationPreferences NotificationPreference[] @relation("UserNotificationPreferences")
  deviceTokens            DeviceToken[]            @relation("UserDeviceTokens")
  notifications           NotificationDelivery[]   @relation("UserNotifications")
  attachments             Attachment[]             @relation("AttachmentUploader")
  
  // Admin and moderation relationships
  adminRoles              AdminRole[]              @relation("UserAdminRoles")
  grantedAdminRoles       AdminRole[]              @relation("AdminRoleGranter")
  moderationActions       ModerationAction[]       @relation("ModeratorActions")
  contentReports          ContentReport[]          @relation("UserReports")
  assignedReports         ContentReport[]          @relation("AssignedReports")
  createdRules            AutoModerationRule[]     @relation("AutoModerationRuleCreator")
  violations              AutoModerationViolation[] @relation("UserViolations")
  reviewedViolations      AutoModerationViolation[] @relation("ViolationReviewer")
  userBans                UserBan[]                @relation("UserBans")
  moderatorBans           UserBan[]                @relation("ModeratorBans")

  @@map("users")
}

// Conversations table supporting both DM and group chats
model Conversation {
  id        String            @id @default(uuid())
  type      ConversationType
  name      String?           @db.VarChar(100)
  ownerId   String?           @map("owner_id")
  createdAt DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  owner               User?                 @relation("ConversationOwner", fields: [ownerId], references: [id])
  members             ConversationMember[]
  messages            Message[]
  conversationState   ConversationState?

  @@map("conversations")
}

// Conversation members with roles and read tracking
model ConversationMember {
  conversationId      String   @map("conversation_id")
  userId              String   @map("user_id")
  role                MemberRole @default(MEMBER)
  lastReadMessageId   String?  @map("last_read_message_id")
  lastReadSequence    BigInt   @default(0) @map("last_read_sequence")
  joinedAt            DateTime @default(now()) @map("joined_at") @db.Timestamptz(6)

  // Relationships
  conversation        Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user                User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  lastReadMessage     Message?     @relation("LastReadMessage", fields: [lastReadMessageId], references: [id])

  @@id([conversationId, userId])
  @@index([userId])
  @@map("conversation_members")
}

// Messages with sequence ordering and content support
model Message {
  id                String      @id @default(uuid())
  conversationId    String      @map("conversation_id")
  senderId          String?     @map("sender_id")
  clientMessageId   String?     @map("client_message_id") @db.VarChar(100)
  sequenceNumber    BigInt      @map("sequence_number")
  messageType       MessageType @default(TEXT) @map("message_type")
  content           Json
  editedAt          DateTime?   @map("edited_at") @db.Timestamptz(6)
  deletedAt         DateTime?   @map("deleted_at") @db.Timestamptz(6)
  createdAt         DateTime    @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  conversation      Conversation        @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender            User?               @relation("MessageSender", fields: [senderId], references: [id])
  reactions         MessageReaction[]
  attachments       Attachment[]
  lastReadBy        ConversationMember[] @relation("LastReadMessage")

  @@unique([conversationId, sequenceNumber])
  @@unique([conversationId, clientMessageId, senderId])
  @@index([conversationId, sequenceNumber(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("messages")
}

// Message reactions
model MessageReaction {
  messageId String   @map("message_id")
  userId    String   @map("user_id")
  emoji     String   @db.VarChar(10)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId, emoji])
  @@map("message_reactions")
}

// Conversation state for sequence number fallback
model ConversationState {
  conversationId String   @id @map("conversation_id")
  lastSeq        BigInt   @default(0) @map("last_seq")
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@map("conversation_state")
}

// Media attachments with enhanced metadata
model Attachment {
  id               String            @id @default(uuid())
  messageId        String            @map("message_id")
  filename         String            @db.VarChar(255)
  originalFilename String            @map("original_filename") @db.VarChar(255)
  mimeType         String            @map("mime_type") @db.VarChar(100)
  fileSize         BigInt            @map("file_size")
  fileHash         String            @map("file_hash") @db.VarChar(64)
  storageUrl       String            @map("storage_url")
  thumbnailUrl     String?           @map("thumbnail_url")
  previewUrl       String?           @map("preview_url")
  uploadStatus     MediaUploadStatus @default(PENDING) @map("upload_status")
  processingStatus MediaProcessingStatus @default(PENDING) @map("processing_status")
  metadata         Json?             // EXIF data, dimensions, duration, etc.
  virusScanStatus  VirusScanStatus   @default(PENDING) @map("virus_scan_status")
  virusScanResult  String?           @map("virus_scan_result")
  contentSafety    Json?             @map("content_safety") // Content moderation results
  cdnUrl           String?           @map("cdn_url")
  expiresAt        DateTime?         @map("expires_at") @db.Timestamptz(6)
  tenantId         String?           @map("tenant_id")
  uploadedBy       String            @map("uploaded_by")
  createdAt        DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime          @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  message          Message           @relation(fields: [messageId], references: [id], onDelete: Cascade)
  uploader         User              @relation("AttachmentUploader", fields: [uploadedBy], references: [id])
  mediaProcessing  MediaProcessing[]

  @@index([messageId])
  @@index([uploadedBy])
  @@index([tenantId])
  @@index([fileHash])
  @@index([uploadStatus])
  @@index([virusScanStatus])
  @@map("attachments")
}

// Media processing jobs and results
model MediaProcessing {
  id           String                @id @default(uuid())
  attachmentId String                @map("attachment_id")
  jobType      MediaProcessingType   @map("job_type")
  status       MediaProcessingStatus @default(PENDING)
  priority     ProcessingPriority    @default(NORMAL)
  inputUrl     String                @map("input_url")
  outputUrl    String?               @map("output_url")
  parameters   Json?                 // Processing parameters (size, quality, etc.)
  result       Json?                 // Processing results and metadata
  error        String?               // Error message if failed
  attempts     Int                   @default(0)
  maxAttempts  Int                   @default(3) @map("max_attempts")
  scheduledAt  DateTime?             @map("scheduled_at") @db.Timestamptz(6)
  startedAt    DateTime?             @map("started_at") @db.Timestamptz(6)
  completedAt  DateTime?             @map("completed_at") @db.Timestamptz(6)
  tenantId     String?               @map("tenant_id")
  createdAt    DateTime              @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime              @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  attachment   Attachment            @relation(fields: [attachmentId], references: [id], onDelete: Cascade)

  @@index([attachmentId])
  @@index([status])
  @@index([jobType])
  @@index([priority])
  @@index([scheduledAt])
  @@index([tenantId])
  @@map("media_processing")
}

// Media quota tracking per tenant
model MediaQuota {
  id              String   @id @default(uuid())
  tenantId        String   @unique @map("tenant_id")
  storageUsed     BigInt   @default(0) @map("storage_used") // bytes
  storageLimit    BigInt   @map("storage_limit") // bytes
  uploadCount     Int      @default(0) @map("upload_count")
  uploadLimit     Int      @map("upload_limit")
  bandwidthUsed   BigInt   @default(0) @map("bandwidth_used") // bytes
  bandwidthLimit  BigInt   @map("bandwidth_limit") // bytes
  resetAt         DateTime @map("reset_at") @db.Timestamptz(6) // monthly reset
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@map("media_quotas")
}

// Audit logs for compliance and moderation
model AuditLog {
  id         String   @id @default(uuid())
  tenantId   String?  @map("tenant_id")
  actorId    String?  @map("actor_id")
  action     String   @db.VarChar(50)
  targetType String   @map("target_type") @db.VarChar(50)
  targetId   String   @map("target_id")
  metadata   Json?
  ipAddress  String?  @map("ip_address")
  userAgent  String?  @map("user_agent")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  actor      User?    @relation("AuditActor", fields: [actorId], references: [id])

  @@index([actorId, createdAt(sort: Desc)])
  @@map("audit_logs")
}

// Outbox pattern for reliable event publishing
model OutboxEvent {
  id            String    @id @default(uuid())
  tenantId      String?   @map("tenant_id")
  aggregateType String    @map("aggregate_type") @db.VarChar(50)
  aggregateId   String    @map("aggregate_id")
  eventType     String    @map("event_type") @db.VarChar(100)
  eventData     Json      @map("event_data")
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  publishedAt   DateTime? @map("published_at") @db.Timestamptz(6)
  retryCount    Int       @default(0) @map("retry_count")

  @@index([createdAt])
  @@map("outbox_events")
}

// Notification preferences for users
model NotificationPreference {
  id                    String  @id @default(uuid())
  userId                String  @map("user_id")
  tenantId              String? @map("tenant_id")
  pushEnabled           Boolean @default(true) @map("push_enabled")
  emailEnabled          Boolean @default(true) @map("email_enabled")
  mentionNotifications  Boolean @default(true) @map("mention_notifications")
  dmNotifications       Boolean @default(true) @map("dm_notifications")
  groupNotifications    Boolean @default(true) @map("group_notifications")
  quietHoursEnabled     Boolean @default(false) @map("quiet_hours_enabled")
  quietHoursStart       String? @map("quiet_hours_start") @db.VarChar(5) // HH:MM format
  quietHoursEnd         String? @map("quiet_hours_end") @db.VarChar(5)   // HH:MM format
  timezone              String  @default("UTC") @db.VarChar(50)
  createdAt             DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user User @relation("UserNotificationPreferences", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@map("notification_preferences")
}

// Device tokens for push notifications
model DeviceToken {
  id           String            @id @default(uuid())
  userId       String            @map("user_id")
  tenantId     String?           @map("tenant_id")
  deviceId     String            @map("device_id") @db.VarChar(255)
  token        String            @db.VarChar(500)
  platform     DevicePlatform
  appVersion   String?           @map("app_version") @db.VarChar(50)
  isActive     Boolean           @default(true) @map("is_active")
  lastUsedAt   DateTime          @default(now()) @map("last_used_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user          User                   @relation("UserDeviceTokens", fields: [userId], references: [id], onDelete: Cascade)
  notifications NotificationDelivery[] @relation("DeviceNotifications")

  @@unique([userId, deviceId, tenantId])
  @@index([userId, isActive])
  @@map("device_tokens")
}

// Notification delivery tracking
model NotificationDelivery {
  id                String                    @id @default(uuid())
  tenantId          String?                   @map("tenant_id")
  userId            String                    @map("user_id")
  notificationType  NotificationType          @map("notification_type")
  deliveryChannel   NotificationChannel       @map("delivery_channel")
  status            NotificationStatus
  title             String                    @db.VarChar(255)
  body              String                    @db.Text
  data              Json?
  deviceTokenId     String?                   @map("device_token_id")
  externalId        String?                   @map("external_id") @db.VarChar(255) // Firebase/Email service ID
  errorMessage      String?                   @map("error_message") @db.Text
  retryCount        Int                       @default(0) @map("retry_count")
  scheduledAt       DateTime?                 @map("scheduled_at") @db.Timestamptz(6)
  sentAt            DateTime?                 @map("sent_at") @db.Timestamptz(6)
  deliveredAt       DateTime?                 @map("delivered_at") @db.Timestamptz(6)
  readAt            DateTime?                 @map("read_at") @db.Timestamptz(6)
  createdAt         DateTime                  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt         DateTime                  @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user        User         @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  deviceToken DeviceToken? @relation("DeviceNotifications", fields: [deviceTokenId], references: [id])

  @@index([userId, status, createdAt(sort: Desc)])
  @@index([tenantId, status, createdAt(sort: Desc)])
  @@index([scheduledAt])
  @@map("notification_deliveries")
}

// Notification templates
model NotificationTemplate {
  id          String               @id @default(uuid())
  tenantId    String?              @map("tenant_id")
  name        String               @db.VarChar(100)
  type        NotificationType
  channel     NotificationChannel
  subject     String?              @db.VarChar(255) // For email notifications
  title       String               @db.VarChar(255)
  body        String               @db.Text
  variables   Json?                // Template variables schema
  isActive    Boolean              @default(true) @map("is_active")
  createdAt   DateTime             @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime             @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@unique([tenantId, name, type, channel])
  @@map("notification_templates")
}

// Enums
enum ConversationType {
  DM    @map("dm")
  GROUP @map("group")
}

enum MemberRole {
  OWNER  @map("owner")
  ADMIN  @map("admin")
  MEMBER @map("member")
}

enum MessageType {
  TEXT   @map("text")
  IMAGE  @map("image")
  FILE   @map("file")
  SYSTEM @map("system")
}

enum DevicePlatform {
  IOS     @map("ios")
  ANDROID @map("android")
  WEB     @map("web")
}

enum NotificationType {
  NEW_MESSAGE           @map("new_message")
  MENTION               @map("mention")
  CONVERSATION_INVITE   @map("conversation_invite")
  USER_JOINED           @map("user_joined")
  USER_LEFT             @map("user_left")
  MESSAGE_REACTION      @map("message_reaction")
  SYSTEM_ANNOUNCEMENT   @map("system_announcement")
}

enum NotificationChannel {
  PUSH  @map("push")
  EMAIL @map("email")
  SMS   @map("sms")
}

enum NotificationStatus {
  PENDING    @map("pending")
  SCHEDULED  @map("scheduled")
  SENT       @map("sent")
  DELIVERED  @map("delivered")
  READ       @map("read")
  FAILED     @map("failed")
  CANCELLED  @map("cancelled")
}

enum MediaUploadStatus {
  PENDING    @map("pending")
  UPLOADING  @map("uploading")
  UPLOADED   @map("uploaded")
  FAILED     @map("failed")
  CANCELLED  @map("cancelled")
}

enum MediaProcessingStatus {
  PENDING      @map("pending")
  PROCESSING   @map("processing")
  COMPLETED    @map("completed")
  FAILED       @map("failed")
  SKIPPED      @map("skipped")
}

enum MediaProcessingType {
  THUMBNAIL_GENERATION @map("thumbnail_generation")
  IMAGE_RESIZE         @map("image_resize")
  VIDEO_TRANSCODE      @map("video_transcode")
  AUDIO_TRANSCODE      @map("audio_transcode")
  EXIF_STRIP           @map("exif_strip")
  WATERMARK            @map("watermark")
  VIRUS_SCAN           @map("virus_scan")
  CONTENT_MODERATION   @map("content_moderation")
}

enum ProcessingPriority {
  LOW      @map("low")
  NORMAL   @map("normal")
  HIGH     @map("high")
  URGENT   @map("urgent")
}

enum VirusScanStatus {
  PENDING    @map("pending")
  SCANNING   @map("scanning")
  CLEAN      @map("clean")
  INFECTED   @map("infected")
  FAILED     @map("failed")
  SKIPPED    @map("skipped")
}

enum SubscriptionTier {
  FREE       @map("free")
  BASIC      @map("basic")
  PREMIUM    @map("premium")
  ENTERPRISE @map("enterprise")
}

// Admin and moderation models
model AdminRole {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  tenantId    String?  @map("tenant_id")
  role        AdminRoleType
  permissions String[] // Array of permission strings
  grantedBy   String   @map("granted_by")
  grantedAt   DateTime @default(now()) @map("granted_at") @db.Timestamptz(6)
  expiresAt   DateTime? @map("expires_at") @db.Timestamptz(6)
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user      User @relation("UserAdminRoles", fields: [userId], references: [id], onDelete: Cascade)
  grantedByUser User @relation("AdminRoleGranter", fields: [grantedBy], references: [id])

  @@unique([userId, tenantId, role])
  @@index([userId, isActive])
  @@index([tenantId, role])
  @@map("admin_roles")
}

model ModerationAction {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  moderatorId  String            @map("moderator_id")
  targetType   ModerationTargetType @map("target_type")
  targetId     String            @map("target_id")
  actionType   ModerationActionType @map("action_type")
  reason       String            @db.Text
  duration     Int?              // Duration in minutes for temporary actions
  metadata     Json?             // Additional action metadata
  isActive     Boolean           @default(true) @map("is_active")
  expiresAt    DateTime?         @map("expires_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  moderator    User              @relation("ModeratorActions", fields: [moderatorId], references: [id])

  @@index([targetType, targetId])
  @@index([moderatorId, createdAt(sort: Desc)])
  @@index([tenantId, actionType])
  @@index([expiresAt])
  @@map("moderation_actions")
}

model ContentReport {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  reporterId   String            @map("reporter_id")
  targetType   ModerationTargetType @map("target_type")
  targetId     String            @map("target_id")
  reportType   ReportType        @map("report_type")
  reason       String            @db.Text
  description  String?           @db.Text
  status       ReportStatus      @default(PENDING)
  priority     ReportPriority    @default(MEDIUM)
  assignedTo   String?           @map("assigned_to")
  resolution   String?           @db.Text
  resolvedAt   DateTime?         @map("resolved_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  reporter     User              @relation("UserReports", fields: [reporterId], references: [id])
  assignee     User?             @relation("AssignedReports", fields: [assignedTo], references: [id])

  @@index([reporterId])
  @@index([targetType, targetId])
  @@index([status, priority])
  @@index([tenantId, status])
  @@index([assignedTo])
  @@map("content_reports")
}

model AutoModerationRule {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  name         String            @db.VarChar(100)
  description  String?           @db.Text
  ruleType     AutoModerationRuleType @map("rule_type")
  conditions   Json              // Rule conditions and thresholds
  actions      Json              // Actions to take when rule is triggered
  isEnabled    Boolean           @default(true) @map("is_enabled")
  severity     RuleSeverity      @default(MEDIUM)
  createdBy    String            @map("created_by")
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  creator      User              @relation("AutoModerationRuleCreator", fields: [createdBy], references: [id])
  violations   AutoModerationViolation[]

  @@unique([tenantId, name])
  @@index([tenantId, isEnabled])
  @@index([ruleType])
  @@map("auto_moderation_rules")
}

model AutoModerationViolation {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  ruleId       String            @map("rule_id")
  targetType   ModerationTargetType @map("target_type")
  targetId     String            @map("target_id")
  userId       String?           @map("user_id")
  severity     RuleSeverity
  content      String?           @db.Text // Offending content snapshot
  confidence   Float             // Confidence score (0-1)
  metadata     Json?             // Detection metadata
  actionTaken  Json?             @map("action_taken") // Automated actions performed
  reviewStatus ReviewStatus      @default(PENDING) @map("review_status")
  reviewedBy   String?           @map("reviewed_by")
  reviewedAt   DateTime?         @map("reviewed_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  rule         AutoModerationRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  user         User?              @relation("UserViolations", fields: [userId], references: [id])
  reviewer     User?              @relation("ViolationReviewer", fields: [reviewedBy], references: [id])

  @@index([ruleId])
  @@index([targetType, targetId])
  @@index([userId, createdAt(sort: Desc)])
  @@index([tenantId, reviewStatus])
  @@index([severity, createdAt(sort: Desc)])
  @@map("auto_moderation_violations")
}

model UserBan {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  userId       String            @map("user_id")
  bannedBy     String            @map("banned_by")
  banType      BanType
  reason       String            @db.Text
  duration     Int?              // Duration in minutes for temporary bans
  isActive     Boolean           @default(true) @map("is_active")
  expiresAt    DateTime?         @map("expires_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user         User              @relation("UserBans", fields: [userId], references: [id], onDelete: Cascade)
  moderator    User              @relation("ModeratorBans", fields: [bannedBy], references: [id])

  @@unique([userId, tenantId, banType])
  @@index([userId, isActive])
  @@index([tenantId, isActive])
  @@index([expiresAt])
  @@map("user_bans")
}

// New admin and moderation enums
enum AdminRoleType {
  SUPER_ADMIN    @map("super_admin")
  TENANT_ADMIN   @map("tenant_admin")
  MODERATOR      @map("moderator")
  SUPPORT        @map("support")
}

enum ModerationTargetType {
  USER         @map("user")
  MESSAGE      @map("message")
  CONVERSATION @map("conversation")
  ATTACHMENT   @map("attachment")
}

enum ModerationActionType {
  WARN         @map("warn")
  MUTE         @map("mute")
  KICK         @map("kick")
  BAN          @map("ban")
  DELETE       @map("delete")
  EDIT         @map("edit")
  QUARANTINE   @map("quarantine")
  RESTORE      @map("restore")
}

enum ReportType {
  SPAM         @map("spam")
  HARASSMENT   @map("harassment")
  HATE_SPEECH  @map("hate_speech")
  VIOLENCE     @map("violence")
  INAPPROPRIATE_CONTENT @map("inappropriate_content")
  COPYRIGHT    @map("copyright")
  IMPERSONATION @map("impersonation")
  OTHER        @map("other")
}

enum ReportStatus {
  PENDING      @map("pending")
  INVESTIGATING @map("investigating")
  RESOLVED     @map("resolved")
  DISMISSED    @map("dismissed")
  ESCALATED    @map("escalated")
}

enum ReportPriority {
  LOW          @map("low")
  MEDIUM       @map("medium")
  HIGH         @map("high")
  URGENT       @map("urgent")
}

enum AutoModerationRuleType {
  SPAM_DETECTION     @map("spam_detection")
  PROFANITY_FILTER   @map("profanity_filter")
  RATE_LIMITING      @map("rate_limiting")
  CONTENT_SIMILARITY @map("content_similarity")
  LINK_FILTER        @map("link_filter")
  CAPS_FILTER        @map("caps_filter")
  MENTION_SPAM       @map("mention_spam")
  IMAGE_MODERATION   @map("image_moderation")
}

enum RuleSeverity {
  LOW          @map("low")
  MEDIUM       @map("medium")
  HIGH         @map("high")
  CRITICAL     @map("critical")
}

enum ReviewStatus {
  PENDING      @map("pending")
  APPROVED     @map("approved")
  REJECTED     @map("rejected")
  ESCALATED    @map("escalated")
}

enum BanType {
  TEMPORARY    @map("temporary")
  PERMANENT    @map("permanent")
  SHADOW       @map("shadow")
}

// Security and Compliance Models

// Data retention policies for GDPR compliance
model DataRetentionPolicy {
  id                    String   @id @default(uuid())
  tenantId              String   @map("tenant_id")
  name                  String   @db.VarChar(100)
  description           String?  @db.Text
  dataType              DataType @map("data_type")
  retentionPeriodDays   Int      @map("retention_period_days")
  isActive              Boolean  @default(true) @map("is_active")
  autoDelete            Boolean  @default(false) @map("auto_delete")
  notifyBeforeDeletion  Boolean  @default(true) @map("notify_before_deletion")
  notificationDays      Int      @default(7) @map("notification_days")
  createdAt             DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@unique([tenantId, name])
  @@index([tenantId, isActive])
  @@index([dataType])
  @@map("data_retention_policies")
}

// Enhanced audit logs for security compliance
model AuditLog {
  id            String        @id @default(uuid())
  tenantId      String?       @map("tenant_id")
  userId        String?       @map("user_id")
  sessionId     String?       @map("session_id")
  action        AuditAction
  resource      AuditResource
  resourceId    String        @map("resource_id")
  details       Json
  ipAddress     String        @map("ip_address")
  userAgent     String        @map("user_agent")
  timestamp     DateTime      @default(now()) @db.Timestamptz(6)
  correlationId String?       @map("correlation_id")
  severity      AuditSeverity
  outcome       AuditOutcome
  metadata      Json?

  @@index([tenantId, timestamp(sort: Desc)])
  @@index([userId, timestamp(sort: Desc)])
  @@index([action, timestamp(sort: Desc)])
  @@index([correlationId])
  @@index([severity, timestamp(sort: Desc)])
  @@map("audit_logs_enhanced")
}

// Security events for monitoring and alerting
model SecurityEvent {
  id          String            @id @default(uuid())
  tenantId    String            @map("tenant_id")
  eventType   SecurityEventType @map("event_type")
  severity    SecuritySeverity
  source      String            @db.VarChar(100)
  userId      String?           @map("user_id")
  ipAddress   String            @map("ip_address")
  userAgent   String?           @map("user_agent")
  details     Json
  timestamp   DateTime          @default(now()) @db.Timestamptz(6)
  resolved    Boolean           @default(false)
  resolvedAt  DateTime?         @map("resolved_at") @db.Timestamptz(6)
  resolvedBy  String?           @map("resolved_by")
  tags        String[]

  @@index([tenantId, timestamp(sort: Desc)])
  @@index([eventType, timestamp(sort: Desc)])
  @@index([severity, timestamp(sort: Desc)])
  @@index([resolved, timestamp(sort: Desc)])
  @@index([userId, timestamp(sort: Desc)])
  @@map("security_events")
}

// Anomaly detection results
model AnomalyDetection {
  id            String          @id @default(uuid())
  tenantId      String          @map("tenant_id")
  userId        String?         @map("user_id")
  anomalyType   AnomalyType     @map("anomaly_type")
  severity      AnomalySeverity
  confidence    Float           // 0.0 to 1.0
  description   String          @db.Text
  evidence      Json
  timestamp     DateTime        @default(now()) @db.Timestamptz(6)
  investigated  Boolean         @default(false)
  falsePositive Boolean         @default(false) @map("false_positive")

  @@index([tenantId, timestamp(sort: Desc)])
  @@index([userId, timestamp(sort: Desc)])
  @@index([anomalyType, timestamp(sort: Desc)])
  @@index([severity, timestamp(sort: Desc)])
  @@index([investigated])
  @@map("anomaly_detections")
}

// Geographic access control rules
model GeoAccessRule {
  id        String   @id @default(uuid())
  tenantId  String   @map("tenant_id")
  name      String   @db.VarChar(100)
  ruleType  String   @map("rule_type") // 'allow' or 'block'
  countries String[]
  regions   String[]
  cities    String[]
  ipRanges  String[] @map("ip_ranges")
  isActive  Boolean  @default(true) @map("is_active")
  priority  Int      @default(0)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@unique([tenantId, name])
  @@index([tenantId, isActive])
  @@index([priority])
  @@map("geo_access_rules")
}

// Security incidents for incident response
model SecurityIncident {
  id          String           @id @default(uuid())
  tenantId    String           @map("tenant_id")
  title       String           @db.VarChar(255)
  description String           @db.Text
  severity    IncidentSeverity
  status      IncidentStatus
  category    IncidentCategory
  assignedTo  String?          @map("assigned_to")
  createdAt   DateTime         @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime         @updatedAt @map("updated_at") @db.Timestamptz(6)
  resolvedAt  DateTime?        @map("resolved_at") @db.Timestamptz(6)
  events      String[]         // Security event IDs
  anomalies   String[]         // Anomaly detection IDs
  metadata    Json?

  // Relationships
  actions     IncidentAction[]

  @@index([tenantId, status, createdAt(sort: Desc)])
  @@index([severity, createdAt(sort: Desc)])
  @@index([assignedTo])
  @@index([category, status])
  @@map("security_incidents")
}

// Incident actions for tracking response activities
model IncidentAction {
  id          String       @id @default(uuid())
  incidentId  String       @map("incident_id")
  actionType  ActionType   @map("action_type")
  description String       @db.Text
  executedAt  DateTime     @default(now()) @map("executed_at") @db.Timestamptz(6)
  executedBy  String       @map("executed_by")
  result      ActionResult
  details     Json?

  // Relationships
  incident    SecurityIncident @relation(fields: [incidentId], references: [id], onDelete: Cascade)

  @@index([incidentId, executedAt(sort: Desc)])
  @@index([actionType])
  @@index([executedBy])
  @@map("incident_actions")
}

// Automation rules for incident response
model AutomationRule {
  id          String               @id @default(uuid())
  tenantId    String               @map("tenant_id")
  name        String               @db.VarChar(100)
  description String?              @db.Text
  isActive    Boolean              @default(true) @map("is_active")
  triggers    Json                 // AutomationTrigger[]
  conditions  Json                 // AutomationCondition[]
  actions     Json                 // AutomationAction[]
  priority    Int                  @default(0)
  createdAt   DateTime             @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime             @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@unique([tenantId, name])
  @@index([tenantId, isActive])
  @@index([priority])
  @@map("automation_rules")
}

// Security and compliance enums
enum DataType {
  USER_PROFILE    @map("user_profile")
  MESSAGES        @map("messages")
  CONVERSATIONS   @map("conversations")
  ATTACHMENTS     @map("attachments")
  NOTIFICATIONS   @map("notifications")
  AUDIT_LOGS      @map("audit_logs")
  DEVICE_TOKENS   @map("device_tokens")
  SESSION_DATA    @map("session_data")
}

enum AuditAction {
  CREATE              @map("create")
  READ                @map("read")
  UPDATE              @map("update")
  DELETE              @map("delete")
  LOGIN               @map("login")
  LOGOUT              @map("logout")
  EXPORT              @map("export")
  IMPORT              @map("import")
  ADMIN_ACTION        @map("admin_action")
  PERMISSION_CHANGE   @map("permission_change")
  CONFIGURATION_CHANGE @map("configuration_change")
}

enum AuditResource {
  USER         @map("user")
  MESSAGE      @map("message")
  CONVERSATION @map("conversation")
  ATTACHMENT   @map("attachment")
  NOTIFICATION @map("notification")
  ADMIN_ROLE   @map("admin_role")
  TENANT       @map("tenant")
  SYSTEM       @map("system")
}

enum AuditSeverity {
  LOW      @map("low")
  MEDIUM   @map("medium")
  HIGH     @map("high")
  CRITICAL @map("critical")
}

enum AuditOutcome {
  SUCCESS @map("success")
  FAILURE @map("failure")
  PARTIAL @map("partial")
}

// Security Policy Models
model SecurityPolicy {
  id          String   @id @default(uuid())
  name        String   @db.VarChar(100)
  description String?  @db.Text
  isEnabled   Boolean  @default(true) @map("is_enabled")
  priority    Int      @default(0)
  conditions  Json     @default("{}")
  actions     String[] @default([])
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)
  tenantId    String?  @map("tenant_id")

  // Relationships
  tenant  Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("security_policies")
}

// Vulnerability Scan Results
model VulnerabilityScan {
  id           String   @id @default(uuid())
  type         String   @db.VarChar(50)
  status       String   @db.VarChar(20)
  issues       Json     @default("[]")
  summary      Json     @default("{}")
  startedAt    DateTime @map("started_at") @db.Timestamptz(6)
  completedAt  DateTime? @map("completed_at") @db.Timestamptz(6)
  error        String?  @db.Text
  tenantId     String?  @map("tenant_id")
  initiatedBy  String?  @map("initiated_by") @db.VarChar(36)

  // Relationships
  tenant  Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [initiatedBy], references: [id], onDelete: SetNull)

  @@map("vulnerability_scans")
}

// Security Events (extending existing enum)
enum SecurityEventType {
  // Authentication Events
  AUTHENTICATION_FAILURE  @map("authentication_failure")
  AUTHENTICATION_SUCCESS  @map("authentication_success")
  PASSWORD_CHANGE         @map("password_change")
  MFA_ENABLED            @map("mfa_enabled")
  MFA_DISABLED           @map("mfa_disabled")
  
  // Authorization Events
  AUTHORIZATION_FAILURE   @map("authorization_failure")
  PERMISSION_GRANTED      @map("permission_granted")
  PERMISSION_REVOKED      @map("permission_revoked")
  ROLE_ASSIGNED          @map("role_assigned")
  ROLE_REVOKED           @map("role_revoked")
  
  // Security Events
  SUSPICIOUS_LOGIN        @map("suspicious_login")
  BRUTE_FORCE_ATTEMPT     @map("brute_force_attempt")
  RATE_LIMIT_EXCEEDED     @map("rate_limit_exceeded")
  GEO_BLOCKED             @map("geo_blocked")
  
  // Policy Events
  POLICY_CREATED          @map("policy_created")
  POLICY_UPDATED          @map("policy_updated")
  POLICY_DELETED          @map("policy_deleted")
  POLICY_EVALUATION       @map("policy_evaluation")
  
  // Vulnerability Events
  VULNERABILITY_FOUND     @map("vulnerability_found")
  VULNERABILITY_FIXED     @map("vulnerability_fixed")
  SCAN_STARTED            @map("scan_started")
  SCAN_COMPLETED          @map("scan_completed")
  SCAN_FAILED             @map("scan_failed")
  
  // Data Protection Events
  DATA_ACCESS             @map("data_access")
  DATA_MODIFICATION       @map("data_modification")
  DATA_DELETION           @map("data_deletion")
  DATA_EXPORT             @map("data_export")
  
  // Compliance Events
  DATA_RETENTION_PROCESS  @map("data_retention_process")
  USER_DATA_DELETED       @map("user_data_deleted")
  CONSENT_UPDATED         @map("consent_updated")
  RATE_LIMIT_EXCEEDED     @map("rate_limit_exceeded")
  UNUSUAL_ACCESS_PATTERN  @map("unusual_access_pattern")
  PRIVILEGE_ESCALATION    @map("privilege_escalation")
  DATA_EXFILTRATION       @map("data_exfiltration")
  MALICIOUS_PAYLOAD       @map("malicious_payload")
  SYSTEM_INTRUSION        @map("system_intrusion")
  POLICY_VIOLATION        @map("policy_violation")
  ANOMALOUS_BEHAVIOR      @map("anomalous_behavior")
}

enum SecuritySeverity {
  INFO     @map("info")
  LOW      @map("low")
  MEDIUM   @map("medium")
  HIGH     @map("high")
  CRITICAL @map("critical")
}

enum AnomalyType {
  UNUSUAL_LOGIN_TIME      @map("unusual_login_time")
  UNUSUAL_LOCATION        @map("unusual_location")
  EXCESSIVE_API_CALLS     @map("excessive_api_calls")
  UNUSUAL_DATA_ACCESS     @map("unusual_data_access")
  SUSPICIOUS_USER_AGENT   @map("suspicious_user_agent")
  RAPID_PERMISSION_CHANGES @map("rapid_permission_changes")
  BULK_DATA_OPERATIONS    @map("bulk_data_operations")
  UNUSUAL_DEVICE          @map("unusual_device")
}

enum AnomalySeverity {
  LOW      @map("low")
  MEDIUM   @map("medium")
  HIGH     @map("high")
  CRITICAL @map("critical")
}

enum IncidentSeverity {
  LOW      @map("low")
  MEDIUM   @map("medium")
  HIGH     @map("high")
  CRITICAL @map("critical")
}

enum IncidentStatus {
  OPEN          @map("open")
  INVESTIGATING @map("investigating")
  CONTAINED     @map("contained")
  RESOLVED      @map("resolved")
  CLOSED        @map("closed")
}

enum IncidentCategory {
  AUTHENTICATION @map("authentication")
  AUTHORIZATION  @map("authorization")
  DATA_BREACH    @map("data_breach")
  MALWARE        @map("malware")
  PHISHING       @map("phishing")
  DDOS           @map("ddos")
  INSIDER_THREAT @map("insider_threat")
  SYSTEM_COMPROMISE @map("system_compromise")
  POLICY_VIOLATION @map("policy_violation")
  OTHER          @map("other")
}

enum ActionType {
  BLOCK_IP         @map("block_ip")
  BLOCK_USER       @map("block_user")
  REVOKE_SESSION   @map("revoke_session")
  SEND_ALERT       @map("send_alert")
  CREATE_INCIDENT  @map("create_incident")
  ESCALATE         @map("escalate")
  QUARANTINE       @map("quarantine")
  COLLECT_EVIDENCE @map("collect_evidence")
  NOTIFY_ADMIN     @map("notify_admin")
  DISABLE_ACCOUNT  @map("disable_account")
}

enum ActionResult {
  SUCCESS @map("success")
  FAILURE @map("failure")
  PARTIAL @map("partial")
  PENDING @map("pending")
}
