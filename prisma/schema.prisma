// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Tenants table for multi-tenancy support
model Tenant {
  id               String           @id @default(uuid())
  name             String           @unique @db.VarChar(100)
  subscriptionTier SubscriptionTier @default(FREE) @map("subscription_tier")
  isActive         Boolean          @default(true) @map("is_active")
  createdAt        DateTime         @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime         @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  settings TenantSettings?
  quota    TenantQuota?
  usage    TenantUsage?

  @@map("tenants")
}

// Tenant settings and configuration
model TenantSettings {
  tenantId          String   @id @map("tenant_id")
  allowFileUploads  Boolean  @default(true) @map("allow_file_uploads")
  maxFileSize       Int      @map("max_file_size") // bytes
  allowedFileTypes  String[] @map("allowed_file_types")
  retentionDays     Int      @default(30) @map("retention_days")
  enableNotifications Boolean @default(true) @map("enable_notifications")
  enableSearch      Boolean  @default(true) @map("enable_search")
  customBranding    Boolean  @default(false) @map("custom_branding")
  ssoEnabled        Boolean  @default(false) @map("sso_enabled")
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt         DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("tenant_settings")
}

// Tenant quota limits
model TenantQuota {
  tenantId                String @id @map("tenant_id")
  maxUsers                Int    @map("max_users")
  maxConversations        Int    @map("max_conversations")
  maxMessagesPerDay       Int    @map("max_messages_per_day")
  maxStorageBytes         BigInt @map("max_storage_bytes")
  maxConnectionsPerUser   Int    @map("max_connections_per_user")
  maxApiRequestsPerHour   Int    @map("max_api_requests_per_hour")
  createdAt               DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt               DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("tenant_quotas")
}

// Tenant usage tracking
model TenantUsage {
  tenantId              String   @id @map("tenant_id")
  currentUsers          Int      @default(0) @map("current_users")
  currentConversations  Int      @default(0) @map("current_conversations")
  messagesUsedToday     Int      @default(0) @map("messages_used_today")
  storageUsedBytes      BigInt   @default(0) @map("storage_used_bytes")
  currentConnections    Int      @default(0) @map("current_connections")
  apiRequestsThisHour   Int      @default(0) @map("api_requests_this_hour")
  createdAt             DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("tenant_usage")
}

// Users table with authentication and MFA support
model User {
  id           String   @id @default(uuid())
  username     String   @unique @db.VarChar(50)
  displayName  String   @map("display_name") @db.VarChar(100)
  email        String   @unique @db.VarChar(255)
  passwordHash String   @map("password_hash") @db.VarChar(255)
  mfaEnabled   Boolean  @default(false) @map("mfa_enabled")
  mfaSecret    String?  @map("mfa_secret") @db.VarChar(255)
  lastLoginAt  DateTime? @map("last_login_at") @db.Timestamptz(6)
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  ownedConversations      Conversation[]           @relation("ConversationOwner")
  conversationMembers     ConversationMember[]
  sentMessages            Message[]                @relation("MessageSender")
  messageReactions        MessageReaction[]
  auditLogs               AuditLog[]               @relation("AuditActor")
  notificationPreferences NotificationPreference[] @relation("UserNotificationPreferences")
  deviceTokens            DeviceToken[]            @relation("UserDeviceTokens")
  notifications           NotificationDelivery[]   @relation("UserNotifications")
  attachments             Attachment[]             @relation("AttachmentUploader")
  
  // Admin and moderation relationships
  adminRoles              AdminRole[]              @relation("UserAdminRoles")
  grantedAdminRoles       AdminRole[]              @relation("AdminRoleGranter")
  moderationActions       ModerationAction[]       @relation("ModeratorActions")
  contentReports          ContentReport[]          @relation("UserReports")
  assignedReports         ContentReport[]          @relation("AssignedReports")
  createdRules            AutoModerationRule[]     @relation("AutoModerationRuleCreator")
  violations              AutoModerationViolation[] @relation("UserViolations")
  reviewedViolations      AutoModerationViolation[] @relation("ViolationReviewer")
  userBans                UserBan[]                @relation("UserBans")
  moderatorBans           UserBan[]                @relation("ModeratorBans")

  @@map("users")
}

// Conversations table supporting both DM and group chats
model Conversation {
  id        String            @id @default(uuid())
  type      ConversationType
  name      String?           @db.VarChar(100)
  ownerId   String?           @map("owner_id")
  createdAt DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  owner               User?                 @relation("ConversationOwner", fields: [ownerId], references: [id])
  members             ConversationMember[]
  messages            Message[]
  conversationState   ConversationState?

  @@map("conversations")
}

// Conversation members with roles and read tracking
model ConversationMember {
  conversationId      String   @map("conversation_id")
  userId              String   @map("user_id")
  role                MemberRole @default(MEMBER)
  lastReadMessageId   String?  @map("last_read_message_id")
  lastReadSequence    BigInt   @default(0) @map("last_read_sequence")
  joinedAt            DateTime @default(now()) @map("joined_at") @db.Timestamptz(6)

  // Relationships
  conversation        Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user                User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  lastReadMessage     Message?     @relation("LastReadMessage", fields: [lastReadMessageId], references: [id])

  @@id([conversationId, userId])
  @@index([userId])
  @@map("conversation_members")
}

// Messages with sequence ordering and content support
model Message {
  id                String      @id @default(uuid())
  conversationId    String      @map("conversation_id")
  senderId          String?     @map("sender_id")
  clientMessageId   String?     @map("client_message_id") @db.VarChar(100)
  sequenceNumber    BigInt      @map("sequence_number")
  messageType       MessageType @default(TEXT) @map("message_type")
  content           Json
  editedAt          DateTime?   @map("edited_at") @db.Timestamptz(6)
  deletedAt         DateTime?   @map("deleted_at") @db.Timestamptz(6)
  createdAt         DateTime    @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  conversation      Conversation        @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender            User?               @relation("MessageSender", fields: [senderId], references: [id])
  reactions         MessageReaction[]
  attachments       Attachment[]
  lastReadBy        ConversationMember[] @relation("LastReadMessage")

  @@unique([conversationId, sequenceNumber])
  @@unique([conversationId, clientMessageId, senderId])
  @@index([conversationId, sequenceNumber(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("messages")
}

// Message reactions
model MessageReaction {
  messageId String   @map("message_id")
  userId    String   @map("user_id")
  emoji     String   @db.VarChar(10)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId, emoji])
  @@map("message_reactions")
}

// Conversation state for sequence number fallback
model ConversationState {
  conversationId String   @id @map("conversation_id")
  lastSeq        BigInt   @default(0) @map("last_seq")
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@map("conversation_state")
}

// Media attachments with enhanced metadata
model Attachment {
  id               String            @id @default(uuid())
  messageId        String            @map("message_id")
  filename         String            @db.VarChar(255)
  originalFilename String            @map("original_filename") @db.VarChar(255)
  mimeType         String            @map("mime_type") @db.VarChar(100)
  fileSize         BigInt            @map("file_size")
  fileHash         String            @map("file_hash") @db.VarChar(64)
  storageUrl       String            @map("storage_url")
  thumbnailUrl     String?           @map("thumbnail_url")
  previewUrl       String?           @map("preview_url")
  uploadStatus     MediaUploadStatus @default(PENDING) @map("upload_status")
  processingStatus MediaProcessingStatus @default(PENDING) @map("processing_status")
  metadata         Json?             // EXIF data, dimensions, duration, etc.
  virusScanStatus  VirusScanStatus   @default(PENDING) @map("virus_scan_status")
  virusScanResult  String?           @map("virus_scan_result")
  contentSafety    Json?             @map("content_safety") // Content moderation results
  cdnUrl           String?           @map("cdn_url")
  expiresAt        DateTime?         @map("expires_at") @db.Timestamptz(6)
  tenantId         String?           @map("tenant_id")
  uploadedBy       String            @map("uploaded_by")
  createdAt        DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime          @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  message          Message           @relation(fields: [messageId], references: [id], onDelete: Cascade)
  uploader         User              @relation("AttachmentUploader", fields: [uploadedBy], references: [id])
  mediaProcessing  MediaProcessing[]

  @@index([messageId])
  @@index([uploadedBy])
  @@index([tenantId])
  @@index([fileHash])
  @@index([uploadStatus])
  @@index([virusScanStatus])
  @@map("attachments")
}

// Media processing jobs and results
model MediaProcessing {
  id           String                @id @default(uuid())
  attachmentId String                @map("attachment_id")
  jobType      MediaProcessingType   @map("job_type")
  status       MediaProcessingStatus @default(PENDING)
  priority     ProcessingPriority    @default(NORMAL)
  inputUrl     String                @map("input_url")
  outputUrl    String?               @map("output_url")
  parameters   Json?                 // Processing parameters (size, quality, etc.)
  result       Json?                 // Processing results and metadata
  error        String?               // Error message if failed
  attempts     Int                   @default(0)
  maxAttempts  Int                   @default(3) @map("max_attempts")
  scheduledAt  DateTime?             @map("scheduled_at") @db.Timestamptz(6)
  startedAt    DateTime?             @map("started_at") @db.Timestamptz(6)
  completedAt  DateTime?             @map("completed_at") @db.Timestamptz(6)
  tenantId     String?               @map("tenant_id")
  createdAt    DateTime              @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime              @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  attachment   Attachment            @relation(fields: [attachmentId], references: [id], onDelete: Cascade)

  @@index([attachmentId])
  @@index([status])
  @@index([jobType])
  @@index([priority])
  @@index([scheduledAt])
  @@index([tenantId])
  @@map("media_processing")
}

// Media quota tracking per tenant
model MediaQuota {
  id              String   @id @default(uuid())
  tenantId        String   @unique @map("tenant_id")
  storageUsed     BigInt   @default(0) @map("storage_used") // bytes
  storageLimit    BigInt   @map("storage_limit") // bytes
  uploadCount     Int      @default(0) @map("upload_count")
  uploadLimit     Int      @map("upload_limit")
  bandwidthUsed   BigInt   @default(0) @map("bandwidth_used") // bytes
  bandwidthLimit  BigInt   @map("bandwidth_limit") // bytes
  resetAt         DateTime @map("reset_at") @db.Timestamptz(6) // monthly reset
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@map("media_quotas")
}

// Audit logs for compliance and moderation
model AuditLog {
  id         String   @id @default(uuid())
  tenantId   String?  @map("tenant_id")
  actorId    String?  @map("actor_id")
  action     String   @db.VarChar(50)
  targetType String   @map("target_type") @db.VarChar(50)
  targetId   String   @map("target_id")
  metadata   Json?
  ipAddress  String?  @map("ip_address")
  userAgent  String?  @map("user_agent")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  actor      User?    @relation("AuditActor", fields: [actorId], references: [id])

  @@index([actorId, createdAt(sort: Desc)])
  @@map("audit_logs")
}

// Outbox pattern for reliable event publishing
model OutboxEvent {
  id            String    @id @default(uuid())
  tenantId      String?   @map("tenant_id")
  aggregateType String    @map("aggregate_type") @db.VarChar(50)
  aggregateId   String    @map("aggregate_id")
  eventType     String    @map("event_type") @db.VarChar(100)
  eventData     Json      @map("event_data")
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  publishedAt   DateTime? @map("published_at") @db.Timestamptz(6)
  retryCount    Int       @default(0) @map("retry_count")

  @@index([createdAt])
  @@map("outbox_events")
}

// Notification preferences for users
model NotificationPreference {
  id                    String  @id @default(uuid())
  userId                String  @map("user_id")
  tenantId              String? @map("tenant_id")
  pushEnabled           Boolean @default(true) @map("push_enabled")
  emailEnabled          Boolean @default(true) @map("email_enabled")
  mentionNotifications  Boolean @default(true) @map("mention_notifications")
  dmNotifications       Boolean @default(true) @map("dm_notifications")
  groupNotifications    Boolean @default(true) @map("group_notifications")
  quietHoursEnabled     Boolean @default(false) @map("quiet_hours_enabled")
  quietHoursStart       String? @map("quiet_hours_start") @db.VarChar(5) // HH:MM format
  quietHoursEnd         String? @map("quiet_hours_end") @db.VarChar(5)   // HH:MM format
  timezone              String  @default("UTC") @db.VarChar(50)
  createdAt             DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user User @relation("UserNotificationPreferences", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@map("notification_preferences")
}

// Device tokens for push notifications
model DeviceToken {
  id           String            @id @default(uuid())
  userId       String            @map("user_id")
  tenantId     String?           @map("tenant_id")
  deviceId     String            @map("device_id") @db.VarChar(255)
  token        String            @db.VarChar(500)
  platform     DevicePlatform
  appVersion   String?           @map("app_version") @db.VarChar(50)
  isActive     Boolean           @default(true) @map("is_active")
  lastUsedAt   DateTime          @default(now()) @map("last_used_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user          User                   @relation("UserDeviceTokens", fields: [userId], references: [id], onDelete: Cascade)
  notifications NotificationDelivery[] @relation("DeviceNotifications")

  @@unique([userId, deviceId, tenantId])
  @@index([userId, isActive])
  @@map("device_tokens")
}

// Notification delivery tracking
model NotificationDelivery {
  id                String                    @id @default(uuid())
  tenantId          String?                   @map("tenant_id")
  userId            String                    @map("user_id")
  notificationType  NotificationType          @map("notification_type")
  deliveryChannel   NotificationChannel       @map("delivery_channel")
  status            NotificationStatus
  title             String                    @db.VarChar(255)
  body              String                    @db.Text
  data              Json?
  deviceTokenId     String?                   @map("device_token_id")
  externalId        String?                   @map("external_id") @db.VarChar(255) // Firebase/Email service ID
  errorMessage      String?                   @map("error_message") @db.Text
  retryCount        Int                       @default(0) @map("retry_count")
  scheduledAt       DateTime?                 @map("scheduled_at") @db.Timestamptz(6)
  sentAt            DateTime?                 @map("sent_at") @db.Timestamptz(6)
  deliveredAt       DateTime?                 @map("delivered_at") @db.Timestamptz(6)
  readAt            DateTime?                 @map("read_at") @db.Timestamptz(6)
  createdAt         DateTime                  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt         DateTime                  @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user        User         @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  deviceToken DeviceToken? @relation("DeviceNotifications", fields: [deviceTokenId], references: [id])

  @@index([userId, status, createdAt(sort: Desc)])
  @@index([tenantId, status, createdAt(sort: Desc)])
  @@index([scheduledAt])
  @@map("notification_deliveries")
}

// Notification templates
model NotificationTemplate {
  id          String               @id @default(uuid())
  tenantId    String?              @map("tenant_id")
  name        String               @db.VarChar(100)
  type        NotificationType
  channel     NotificationChannel
  subject     String?              @db.VarChar(255) // For email notifications
  title       String               @db.VarChar(255)
  body        String               @db.Text
  variables   Json?                // Template variables schema
  isActive    Boolean              @default(true) @map("is_active")
  createdAt   DateTime             @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime             @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@unique([tenantId, name, type, channel])
  @@map("notification_templates")
}

// Enums
enum ConversationType {
  DM    @map("dm")
  GROUP @map("group")
}

enum MemberRole {
  OWNER  @map("owner")
  ADMIN  @map("admin")
  MEMBER @map("member")
}

enum MessageType {
  TEXT   @map("text")
  IMAGE  @map("image")
  FILE   @map("file")
  SYSTEM @map("system")
}

enum DevicePlatform {
  IOS     @map("ios")
  ANDROID @map("android")
  WEB     @map("web")
}

enum NotificationType {
  NEW_MESSAGE           @map("new_message")
  MENTION               @map("mention")
  CONVERSATION_INVITE   @map("conversation_invite")
  USER_JOINED           @map("user_joined")
  USER_LEFT             @map("user_left")
  MESSAGE_REACTION      @map("message_reaction")
  SYSTEM_ANNOUNCEMENT   @map("system_announcement")
}

enum NotificationChannel {
  PUSH  @map("push")
  EMAIL @map("email")
  SMS   @map("sms")
}

enum NotificationStatus {
  PENDING    @map("pending")
  SCHEDULED  @map("scheduled")
  SENT       @map("sent")
  DELIVERED  @map("delivered")
  READ       @map("read")
  FAILED     @map("failed")
  CANCELLED  @map("cancelled")
}

enum MediaUploadStatus {
  PENDING    @map("pending")
  UPLOADING  @map("uploading")
  UPLOADED   @map("uploaded")
  FAILED     @map("failed")
  CANCELLED  @map("cancelled")
}

enum MediaProcessingStatus {
  PENDING      @map("pending")
  PROCESSING   @map("processing")
  COMPLETED    @map("completed")
  FAILED       @map("failed")
  SKIPPED      @map("skipped")
}

enum MediaProcessingType {
  THUMBNAIL_GENERATION @map("thumbnail_generation")
  IMAGE_RESIZE         @map("image_resize")
  VIDEO_TRANSCODE      @map("video_transcode")
  AUDIO_TRANSCODE      @map("audio_transcode")
  EXIF_STRIP           @map("exif_strip")
  WATERMARK            @map("watermark")
  VIRUS_SCAN           @map("virus_scan")
  CONTENT_MODERATION   @map("content_moderation")
}

enum ProcessingPriority {
  LOW      @map("low")
  NORMAL   @map("normal")
  HIGH     @map("high")
  URGENT   @map("urgent")
}

enum VirusScanStatus {
  PENDING    @map("pending")
  SCANNING   @map("scanning")
  CLEAN      @map("clean")
  INFECTED   @map("infected")
  FAILED     @map("failed")
  SKIPPED    @map("skipped")
}

enum SubscriptionTier {
  FREE       @map("free")
  BASIC      @map("basic")
  PREMIUM    @map("premium")
  ENTERPRISE @map("enterprise")
}

// Admin and moderation models
model AdminRole {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  tenantId    String?  @map("tenant_id")
  role        AdminRoleType
  permissions String[] // Array of permission strings
  grantedBy   String   @map("granted_by")
  grantedAt   DateTime @default(now()) @map("granted_at") @db.Timestamptz(6)
  expiresAt   DateTime? @map("expires_at") @db.Timestamptz(6)
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user      User @relation("UserAdminRoles", fields: [userId], references: [id], onDelete: Cascade)
  grantedByUser User @relation("AdminRoleGranter", fields: [grantedBy], references: [id])

  @@unique([userId, tenantId, role])
  @@index([userId, isActive])
  @@index([tenantId, role])
  @@map("admin_roles")
}

model ModerationAction {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  moderatorId  String            @map("moderator_id")
  targetType   ModerationTargetType @map("target_type")
  targetId     String            @map("target_id")
  actionType   ModerationActionType @map("action_type")
  reason       String            @db.Text
  duration     Int?              // Duration in minutes for temporary actions
  metadata     Json?             // Additional action metadata
  isActive     Boolean           @default(true) @map("is_active")
  expiresAt    DateTime?         @map("expires_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  moderator    User              @relation("ModeratorActions", fields: [moderatorId], references: [id])

  @@index([targetType, targetId])
  @@index([moderatorId, createdAt(sort: Desc)])
  @@index([tenantId, actionType])
  @@index([expiresAt])
  @@map("moderation_actions")
}

model ContentReport {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  reporterId   String            @map("reporter_id")
  targetType   ModerationTargetType @map("target_type")
  targetId     String            @map("target_id")
  reportType   ReportType        @map("report_type")
  reason       String            @db.Text
  description  String?           @db.Text
  status       ReportStatus      @default(PENDING)
  priority     ReportPriority    @default(MEDIUM)
  assignedTo   String?           @map("assigned_to")
  resolution   String?           @db.Text
  resolvedAt   DateTime?         @map("resolved_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  reporter     User              @relation("UserReports", fields: [reporterId], references: [id])
  assignee     User?             @relation("AssignedReports", fields: [assignedTo], references: [id])

  @@index([reporterId])
  @@index([targetType, targetId])
  @@index([status, priority])
  @@index([tenantId, status])
  @@index([assignedTo])
  @@map("content_reports")
}

model AutoModerationRule {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  name         String            @db.VarChar(100)
  description  String?           @db.Text
  ruleType     AutoModerationRuleType @map("rule_type")
  conditions   Json              // Rule conditions and thresholds
  actions      Json              // Actions to take when rule is triggered
  isEnabled    Boolean           @default(true) @map("is_enabled")
  severity     RuleSeverity      @default(MEDIUM)
  createdBy    String            @map("created_by")
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  creator      User              @relation("AutoModerationRuleCreator", fields: [createdBy], references: [id])
  violations   AutoModerationViolation[]

  @@unique([tenantId, name])
  @@index([tenantId, isEnabled])
  @@index([ruleType])
  @@map("auto_moderation_rules")
}

model AutoModerationViolation {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  ruleId       String            @map("rule_id")
  targetType   ModerationTargetType @map("target_type")
  targetId     String            @map("target_id")
  userId       String?           @map("user_id")
  severity     RuleSeverity
  content      String?           @db.Text // Offending content snapshot
  confidence   Float             // Confidence score (0-1)
  metadata     Json?             // Detection metadata
  actionTaken  Json?             @map("action_taken") // Automated actions performed
  reviewStatus ReviewStatus      @default(PENDING) @map("review_status")
  reviewedBy   String?           @map("reviewed_by")
  reviewedAt   DateTime?         @map("reviewed_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relationships
  rule         AutoModerationRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  user         User?              @relation("UserViolations", fields: [userId], references: [id])
  reviewer     User?              @relation("ViolationReviewer", fields: [reviewedBy], references: [id])

  @@index([ruleId])
  @@index([targetType, targetId])
  @@index([userId, createdAt(sort: Desc)])
  @@index([tenantId, reviewStatus])
  @@index([severity, createdAt(sort: Desc)])
  @@map("auto_moderation_violations")
}

model UserBan {
  id           String            @id @default(uuid())
  tenantId     String?           @map("tenant_id")
  userId       String            @map("user_id")
  bannedBy     String            @map("banned_by")
  banType      BanType
  reason       String            @db.Text
  duration     Int?              // Duration in minutes for temporary bans
  isActive     Boolean           @default(true) @map("is_active")
  expiresAt    DateTime?         @map("expires_at") @db.Timestamptz(6)
  createdAt    DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime          @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  user         User              @relation("UserBans", fields: [userId], references: [id], onDelete: Cascade)
  moderator    User              @relation("ModeratorBans", fields: [bannedBy], references: [id])

  @@unique([userId, tenantId, banType])
  @@index([userId, isActive])
  @@index([tenantId, isActive])
  @@index([expiresAt])
  @@map("user_bans")
}

// New admin and moderation enums
enum AdminRoleType {
  SUPER_ADMIN    @map("super_admin")
  TENANT_ADMIN   @map("tenant_admin")
  MODERATOR      @map("moderator")
  SUPPORT        @map("support")
}

enum ModerationTargetType {
  USER         @map("user")
  MESSAGE      @map("message")
  CONVERSATION @map("conversation")
  ATTACHMENT   @map("attachment")
}

enum ModerationActionType {
  WARN         @map("warn")
  MUTE         @map("mute")
  KICK         @map("kick")
  BAN          @map("ban")
  DELETE       @map("delete")
  EDIT         @map("edit")
  QUARANTINE   @map("quarantine")
  RESTORE      @map("restore")
}

enum ReportType {
  SPAM         @map("spam")
  HARASSMENT   @map("harassment")
  HATE_SPEECH  @map("hate_speech")
  VIOLENCE     @map("violence")
  INAPPROPRIATE_CONTENT @map("inappropriate_content")
  COPYRIGHT    @map("copyright")
  IMPERSONATION @map("impersonation")
  OTHER        @map("other")
}

enum ReportStatus {
  PENDING      @map("pending")
  INVESTIGATING @map("investigating")
  RESOLVED     @map("resolved")
  DISMISSED    @map("dismissed")
  ESCALATED    @map("escalated")
}

enum ReportPriority {
  LOW          @map("low")
  MEDIUM       @map("medium")
  HIGH         @map("high")
  URGENT       @map("urgent")
}

enum AutoModerationRuleType {
  SPAM_DETECTION     @map("spam_detection")
  PROFANITY_FILTER   @map("profanity_filter")
  RATE_LIMITING      @map("rate_limiting")
  CONTENT_SIMILARITY @map("content_similarity")
  LINK_FILTER        @map("link_filter")
  CAPS_FILTER        @map("caps_filter")
  MENTION_SPAM       @map("mention_spam")
  IMAGE_MODERATION   @map("image_moderation")
}

enum RuleSeverity {
  LOW          @map("low")
  MEDIUM       @map("medium")
  HIGH         @map("high")
  CRITICAL     @map("critical")
}

enum ReviewStatus {
  PENDING      @map("pending")
  APPROVED     @map("approved")
  REJECTED     @map("rejected")
  ESCALATED    @map("escalated")
}

enum BanType {
  TEMPORARY    @map("temporary")
  PERMANENT    @map("permanent")
  SHADOW       @map("shadow")
}
